<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>karmazilla/nanopool</title>
<style type="text/css">
/*<![CDATA[*/
    body {
        margin-top: 1.0em;
        margin-left: 0;
        margin-right: 0;
        background-color: #c0daf7;
        font-family: "Trebuchet MS", "Helvetica", "Verdana"; 
        color: #000000;
    }
    .container {
        margin: 0 auto;
        width: 700px;
    }
    h1 { font-size: 3.8em; color: #3f2508; margin-bottom: 3px; }
    h1 .small { font-size: 0.4em; }
    h1 a { text-decoration: none }
    h2 { font-size: 1.5em; color: #3f2508; }
    h3 { text-align: center; color: #3f2508; }
    a { color: #3f2508; }
    .content {
        background-color: white;
        margin: 0 auto;
        border-top: 5px solid #80BBFF;
        border-bottom: 5px solid #80BBFF;
    }
    .description { font-size: 1.2em; margin-top: 30px; margin-bottom: 2px; font-style: italic;}
    .toplinks { text-align: center; border-top: 1px solid #aaa; margin-bottom: 30px; margin-top: 2px; }
    .download { float: right; }
    pre { background: #000; color: #fff; padding: 15px; font-family: "Monaco", "Monospace", "Consolas"}
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .footer { text-align:center; padding-top:30px; font-style: italic; }
/*]]>*/
</style>
    </head>
    <body>
        <p>
            <a href="http://github.com/karmazilla/nanopool"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>
        </p>
        <div class="container">
            <div class="download">
                <a href="http://github.com/karmazilla/nanopool/zipball/master"><img width="90" src="http://github.com/images/modules/download/zip.png" alt="Download Zip"/></a> <a href="http://github.com/karmazilla/nanopool/tarball/master"><img width="90" src="http://github.com/images/modules/download/tar.png" alt="Download Tar ball"/></a>
            </div>
            <h1>
                <a href="http://github.com/karmazilla/nanopool">nanopool</a> <span class="small">by <a href="http://github.com/karmazilla">karmazilla</a></span>
            </h1>
        </div>
        <div class="content">
            <div class="container">
            <div class="description">
                Lightweight and fast JDBC connection pool.
            </div>
            <div class="toplinks">
              <a href="apidocs/1.1/index.html">apidocs</a> &sdot;
              <a href="http://github.com/karmazilla/nanopool/issues">issues</a> &sdot;
              <a href="http://wiki.github.com/karmazilla/nanopool">wiki</a>
            </div>
            <p>
                NanoPool is a lightweight and fast JDBC2 connection pool.
            </p>
            <p>
                It is designed to scale well to many concurrent threads, and with a low overhead. The current implementation does a sequential search from a random starting point, to find a possibly available connection. Then it does a CAS on a marker of that connection to mark it as reserved and returns that connection if the CAS succeeds. But if the CAS fails, then it means that some other thread got the connection first, and so we continue our sequential search, wrapping around the pool if we got to the end.
            </p>
            <p>
                This means that thread contention will be on the <strong>size</strong> of the pool (or the JDBC driver, or the database, or..) as oppose to the internal implementation of the connection pool. Of cause, this scalability will still be constrained by the JDBC driver in use, the number of CPUs a system has and, to a lesser degree, by the O(N) time-complexity of the search.
            </p>
            <p>
                NanoPool, while being a lightweight implementation, is fairly feature complete. Here's a couple of noteworthy things I just want to hightlight:
                <ul>
                    <li>JMX management interface</li>
                    <li>Lock-free implementation</li>
                    <li>No internal threads</li>
                    <li>Hot resize with low overhead</li>
                    <li>Plug-able contention control</li>
                </ul>
                There's more to NanoPool than that, but those five bullets are probably what I would consider the key selling points.
            </p>
            <p>
              NanoPool is designed rather differently from most other connection pools. The implementation is fast and performs well under highly concurrent loads, but it all comes with a number of caveats that may make it unsuitable for certain scenarios. In particular, there are two caveats I would like to mention.
            </p>
            <p>
              First off, NanoPool will, by design saturate the pool and open all connections as soon as possible. Many pools are given an upper and a lower bound for how many connections they should keep around. Most normal pools stay within such bounds such that they weigh the fewest possible open connections against the highest possible throughput. NanoPool does not do this. NanoPool just have a pool size, and it will try to keep all connections open at all times. It is possible to simulate the behavior of normal pools to a degree, by using a ResizingContentionHandler, but this will only allow the pool to grow in the face of contention - it will not shrink. There is no support for automatic pool shrinkage in NanoPool, although it is possible to resize the pool to a smaller size through the JMX interface.
            </p>
            <p>
              The other caveat comes from the fact that NanoPool has no internal threads of its own. This means that the only threads that can do pool maintenance work, such as reestablishing aging connections, are the client threads that call into the pool to either claim or release connections. This may be a problem if you worry a lot about latency and standard deviation in response times. That said, I have not really checked if other pools do any better in this respect, so you should test and check it yourself if this is a concern.
            </p>
            <h2>
                Dependencies
            </h2>
            <p>
                Java SE 5 or better. Nothing else.
            </p>
            <h2>
                Install
            </h2>
            <ol>
                <li>Install Maven2.</li>
                <li>Check out the NanoPool source code with git or download a source ball.</li>
                <li>In the source code directory, run `mvn install`.</li>
            </ol>
            <h2>
                Download
            </h2>
            <p>
                You can download this project in either <a href="http://github.com/karmazilla/nanopool/zipball/master">zip</a> or <a href="http://github.com/karmazilla/nanopool/tarball/master">tar</a> formats.
            </p>
            <p>
                You can also clone the project with <a href="http://git-scm.com">Git</a> by running:
            </p>
            <pre>
$ git clone git://github.com/karmazilla/nanopool
</pre>
            <h2>
                License
            </h2>
            <p>
                Apache 2.0
            </p>
            <h2>Authors</h2>
            <p>
                Christian Vest Hansen (karmazilla@gmail.com)
            </p>
        </div>
        </div>
        <div class="footer container">
            get the source code on GitHub : <a href="http://github.com/karmazilla/nanopool">karmazilla/nanopool</a>
        </div>
    </body>
</html>
